<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>зачет….в форме….экзамена…</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.page-description {
    margin-bottom: 2em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-default_background {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 237, 214, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-default_background {
	color: inherit;
	fill: inherit;
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 237, 214, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-uiBlue { background-color: rgba(35, 131, 226, .07); }
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-transparentGray { background-color: rgba(227, 226, 224, 0); }
.select-value-color-translucentGray { background-color: rgba(0, 0, 0, 0.06); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(249, 228, 188, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }
.select-value-color-pageGlass { background-color: undefined; }
.select-value-color-washGlass { background-color: undefined; }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="b22bfe04-330c-4195-bf34-5b7f5c484a70" class="page sans"><header><img class="page-cover-image" src="https://www.notion.so/images/page-cover/woodcuts_8.jpg" style="object-position:center 0%"/><div class="page-header-icon page-header-icon-with-cover"><span class="icon">🤡</span></div><h1 class="page-title">зачет….в форме….экзамена…</h1><p class="page-description"></p></header><div class="page-body"><p id="a0d9e43f-c408-4bfd-9449-fac6670c76e9" class=""><a href="https://www.notion.so/d05cdbed632b4ab8a87ac97395420176?pvs=21">Алгосы зачет 4 сем (notion.site)</a></p><ul id="540d0485-3c9a-4754-9889-43569e78fdbf" class="toggle"><li><details open=""><summary>1. Жадные алгоритмы. Метод ближайшего соседа, концепция алгоритма, шаги алгоритма,	псевдокод</summary><p id="8d758782-445d-40b5-939f-7a3e1f5037e6" class="">Жадные алгоритмы – это класс алгоритмов, которые принимают локально оптимальные решения на каждом этапе с надеждой, что эти решения приведут к глобально оптимальному решению. Жадные алгоритмы характеризуются тем, что на каждом шаге они выбирают то действие, которое кажется наилучшим в данный момент, не оглядываясь на долгосрочные последствия.</p><p id="3591c7c1-df75-42e3-9d99-985b67bba369" class="">Одним из примеров жадных алгоритмов является метод ближайшего соседа (англ. Nearest Neighbor Algorithm). Этот метод часто используется для решения задач коммивояжера, где нужно найти кратчайший путь, проходящий через все заданные точки ровно один раз.</p><h3 id="2aa85b58-a792-42b1-b189-31a66857d686" class="">Концепция алгоритма</h3><p id="202ead7f-c676-4033-8b64-da59791a68e7" class="">Метод ближайшего соседа заключается в следующем:</p><ol type="1" id="8cc59701-f518-4a95-83ef-88535b543996" class="numbered-list" start="1"><li>Начинаем с произвольной стартовой вершины.</li></ol><ol type="1" id="389af4da-5756-4ccb-ae7c-7d10e596e0b1" class="numbered-list" start="2"><li>На каждом шаге переходим в ближайшую непосещенную вершину.</li></ol><ol type="1" id="e1bafcb0-0bbc-4f12-aaa7-4a9cdee0d042" class="numbered-list" start="3"><li>Продолжаем до тех пор, пока не будут посещены все вершины.</li></ol><ol type="1" id="fe2de5dd-09d5-4c3b-a030-f8a176fc6845" class="numbered-list" start="4"><li>Возвращаемся в стартовую вершину, чтобы завершить цикл.</li></ol><p id="4b5981a4-050c-4532-be60-72c657a21aa0" class=""><strong>Преимущества</strong>:</p><ul id="5c5e0192-0397-452b-97cc-122c7e82a4ff" class="bulleted-list"><li style="list-style-type:disc">Простота реализации.</li></ul><ul id="4779552f-13cd-4b15-a923-e1b7e5d6f228" class="bulleted-list"><li style="list-style-type:disc">Быстрое выполнение на небольших графах.</li></ul><p id="09ca5caa-0a39-4ee7-93c8-3c0bee26c299" class=""><strong>Недостатки</strong>:</p><ul id="7d99486d-944e-45ca-81c3-139f9708db47" class="bulleted-list"><li style="list-style-type:disc">Не гарантирует нахождения глобально оптимального решения.</li></ul><ul id="7c8ab216-6920-4ce4-89bf-3050cecfd65d" class="bulleted-list"><li style="list-style-type:disc">Эффективность алгоритма может значительно ухудшаться на больших графах или графах с нестандартной структурой.</li></ul></details></li></ul><ul id="da6bc006-e62d-4b71-b652-154f2e51cd1c" class="toggle"><li><details open=""><summary>2. Алгоритм ближайшего соседа, модификации и характеристики. </summary><p id="469aaab8-51a1-4844-92eb-12f8ba31e1e4" class="">Алгоритм ближайшего соседа (англ. Nearest Neighbor Algorithm) – это жадный алгоритм, который часто применяется для решения задач коммивояжера. В основе алгоритма лежит принцип выбора на каждом шаге ближайшей непосещенной вершины. Этот алгоритм прост в реализации и быстр в выполнении, однако не всегда гарантирует нахождение глобально оптимального решения.</p><h3 id="f3c1eaa0-3353-49e1-a289-ece22e4ea2e6" class="">Основные этапы алгоритма ближайшего соседа</h3><ol type="1" id="043752eb-d58a-4c1e-9a66-664acd4587a3" class="numbered-list" start="1"><li><strong>Инициализация</strong>: Выбираем начальную вершину и отмечаем её как текущую. Создаем список посещенных вершин, содержащий стартовую вершину.</li></ol><ol type="1" id="c7f67812-2a22-40a4-bbd5-1b75f390e3c8" class="numbered-list" start="2"><li><strong>Выбор следующей вершины</strong>: Находим ближайшую непосещенную вершину относительно текущей вершины.</li></ol><ol type="1" id="ff6dfd07-4e3b-4209-b2de-fc526e3ccac1" class="numbered-list" start="3"><li><strong>Переход</strong>: Переходим в найденную вершину, добавляем её в список посещенных.</li></ol><ol type="1" id="f9b2b46d-c15f-47d8-b176-e1fe016ae9f5" class="numbered-list" start="4"><li><strong>Повторение</strong>: Повторяем шаги 2 и 3 до тех пор, пока не будут посещены все вершины.</li></ol><ol type="1" id="2b0a897d-5091-448e-ac44-ef873251cc6d" class="numbered-list" start="5"><li><strong>Завершение</strong>: Возвращаемся к стартовой вершине, чтобы замкнуть цикл.</li></ol><ul id="80518497-1162-48d0-a491-1720c4c53536" class="bulleted-list"><li style="list-style-type:disc"><strong>Простота реализации</strong>: Алгоритм легко реализуется и не требует сложных структур данных.</li></ul><ul id="d7adc296-d72c-4631-99f9-4706318f4e94" class="bulleted-list"><li style="list-style-type:disc"><strong>Время выполнения</strong>: Время выполнения алгоритма в худшем случае составляет \(O(n^2)\), где \(n\) – число вершин в графе. </li></ul><ul id="89faa6ba-d196-490f-be36-d8cdbefa3d63" class="bulleted-list"><li style="list-style-type:disc"><strong>Качество решения</strong>: Алгоритм не гарантирует нахождение глобально оптимального решения. </li></ul><h3 id="5a01c287-9bdf-4420-9e88-d94f97d2ee55" class="">Модификации алгоритма ближайшего соседа</h3><ol type="1" id="6200cf3b-4846-46d8-85a1-ec77be564439" class="numbered-list" start="1"><li><strong>Метод двойного ближайшего соседа (англ. Double Nearest Neighbor)</strong>:<ul id="be86a6ad-3738-4d38-9737-2927d6a5d975" class="bulleted-list"><li style="list-style-type:disc">Идея заключается в том, чтобы учитывать не только ближайшего, но и второго ближайшего соседа при выборе следующей вершины. Это может помочь избежать локальных минимумов.</li></ul></li></ol><ol type="1" id="26274658-2452-454d-9963-4d509b02ffd9" class="numbered-list" start="2"><li>Начинаем каждую вершину как стартовую</li></ol><p id="0b66e7bf-353f-4ba8-9923-9c95f7e37ff9" class="">
</p><p id="0abdf731-4615-450c-900f-bbd10edd167c" class="">
</p></details></li></ul><ul id="601c5267-3bf8-4c10-8de2-1e318d53f5f5" class="toggle"><li><details open=""><summary>3. Алгоритм имитации отжига, концепция алгоритма, шаги алгоритма, псевдокод</summary><p id="35aced1b-084e-47fd-b979-bc675ec19936" class="">Алгоритм имитации отжига (англ. <em>simulated annealing</em>) — эвристический алгоритм оптимизации.</p><p id="2657c148-0054-42e8-9964-ab51fce64828" class="">Алгоритм вдохновлён процессом отжига в металлургии — техники, заключающейся в нагревании и контролируемом охлаждении металла, чтобы увеличить его кристаллизованность и уменьшить дефекты. Симулированние отжига в переборных задачах может быть использовано для приближённого нахождения глобального минимума функций с большим количеством свободных переменных.</p><p id="2d274ced-6270-429b-a366-5e6fe6acd447" class="">Алгоритм вероятностный и не даёт почти никаких гарантий сходимости</p><figure id="4ac32226-f93c-406a-9d6b-585d28cbd455" class="image"><a href="%D0%B7%D0%B0%D1%87%D0%B5%D1%82%E2%80%A6%20%D0%B2%20%D1%84%D0%BE%D1%80%D0%BC%D0%B5%E2%80%A6%20%D1%8D%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD%D0%B0%E2%80%A6%20b22bfe04330c4195bf345b7f5c484a70/Untitled.png"><img style="width:680px" src="%D0%B7%D0%B0%D1%87%D0%B5%D1%82%E2%80%A6%20%D0%B2%20%D1%84%D0%BE%D1%80%D0%BC%D0%B5%E2%80%A6%20%D1%8D%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD%D0%B0%E2%80%A6%20b22bfe04330c4195bf345b7f5c484a70/Untitled.png"/></a></figure><h3 id="df3aa515-d7bf-4275-86ec-181c80aff92b" class="">Преимущества и недостатки</h3><p id="1c0aa934-a400-442b-b5a5-7be927350e64" class=""><strong>Преимущества</strong>:</p><ul id="8c3b4269-d436-4033-9e7b-618827be54fc" class="bulleted-list"><li style="list-style-type:disc">Способность находить глобальные минимумы за счет возможности выхода из локальных минимумов.</li></ul><ul id="2eb13fe6-adc5-4930-871a-d48162672b1e" class="bulleted-list"><li style="list-style-type:disc">Простота реализации и возможность адаптации к различным задачам.</li></ul><p id="e80d8cd0-9a01-4dc3-8bf0-90064ecaf6df" class=""><strong>Недостатки</strong>:</p><ul id="add8e9c0-86c1-4f22-a240-94ece45c4688" class="bulleted-list"><li style="list-style-type:disc">Зависимость от выбора начальных параметров, таких как начальная температура и график охлаждения.</li></ul><ul id="44bd771d-b1fa-4723-b996-d158a14a66fe" class="bulleted-list"><li style="list-style-type:disc">Время выполнения может быть большим, особенно для сложных задач или при использовании медленного графика охлаждения.</li></ul></details></li></ul><ul id="dbca8743-3757-4ab4-bf71-7f1425778530" class="toggle"><li><details open=""><summary>4. Алгоритм имитации отжига, критерии окончания, выбора вершин, способы оценки качества решений, реализация падения температуры.</summary><p id="7bb133de-e476-457d-8a18-2674f599dd1b" class=""><strong>Алгоритм имитации отжига</strong> — это вероятностный метод оптимизации, вдохновленный процессом отжига металла в металлургии. </p><h3 id="2d6600b2-286a-459b-8a75-a2209f243d73" class="">Критерии окончания</h3><ul id="2b5b3df2-d778-4cea-9be8-dc6f3679b212" class="bulleted-list"><li style="list-style-type:disc">Достижение максимального числа итераций.</li></ul><ul id="1c2dc640-b995-4c3d-97b7-feaf2973098b" class="bulleted-list"><li style="list-style-type:disc">Достижение установленного значения температуры.</li></ul><ul id="d31be885-dc67-4f16-9000-a9083887e95b" class="bulleted-list"><li style="list-style-type:disc">Достижение удовлетворительного качества решения.</li></ul><ul id="ca3eab46-8213-4be8-b938-e6d1f42cf3bc" class="bulleted-list"><li style="list-style-type:disc">Стабилизация решения на протяжении нескольких итераций.</li></ul><h3 id="17d47a99-cec0-47ac-af33-d6de74f9d2e1" class="">Выбор вершин</h3><p id="4db3953a-b3f3-403b-8031-d0a01d800355" class="">Выбор следующего состояния (решения) происходит случайным образом на основе функции перехода. Это может быть изменение текущего решения путем случайных операций (например, перестановки элементов, изменения параметров) или генерация соседних состояний по каким-то эвристикам.</p><h3 id="41503d54-31f0-45ec-ad6b-d714b36be02b" class="">Способы оценки качества решений</h3><p id="cb040ab3-4386-4b81-a3af-c213b45f69ce" class="">Оценка качества решений зависит от конкретной задачи оптимизации и целевой функции. Обычно она производится путем вычисления значения целевой функции для каждого решения. Чем меньше значение целевой функции (или чем больше, если решается задача максимизации), тем лучше качество решения.</p><p id="232e0862-1051-419f-ab8e-75ec8aa33484" class="">Падение температуры происходит согласно выбранной функции охлаждения. Обычно это геометрическое или логарифмическое охлаждение.</p></details></li></ul><ul id="dec3b45c-5f6b-4270-bc41-0272e9c1b9f0" class="toggle"><li><details open=""><summary>5. Алгоритм имитации отжига, псевдокод, модификации муравьиной системы, характеристики</summary><p id="b1f86acd-548e-4830-8604-d80f5556825d" class=""><strong>Алгоритм имитации отжига</strong> представляет собой эвристический метод оптимизации, вдохновленный процессом отжига металла в металлургии. </p><h3 id="b8b0904d-e719-4b22-ab34-df6dae91da09" class=""><strong>Псевдокод алгоритма имитации отжига:</strong></h3><p id="2fa9e774-2637-4efe-9591-6e5af856b2dd" class="">1. Инициализация начального решения S<br/>2. Инициализация начальной температуры T<br/>3. Пока условие остановки не выполнено:<br/>      4. Выбрать новое состояние S&#x27; из соседних состояний текущего состояния S<br/>      5. Вычислить изменение целевой функции ΔE = E(S&#x27;) - E(S)<br/>      6. Если ΔE &lt; 0, принять новое состояние S&#x27;<br/>      7. Иначе, принять новое состояние S&#x27; с вероятностью exp(-ΔE / T)<br/>      8. Уменьшить температуру T (например, с помощью функции охлаждения)<br/></p><h3 id="f08df84a-7538-481e-8159-8d112a0ed330" class="">Модификации алгоритма отжига:</h3><ol type="1" id="7535d72b-6411-4e03-9b8d-669303465605" class="numbered-list" start="1"><li><strong>Адаптивное охлаждение</strong>: Изменение температуры в зависимости от характеристик текущего состояния или степени принятия новых решений.</li></ol><ol type="1" id="ddb31910-90ae-4965-b9c4-917cc1e4737d" class="numbered-list" start="2"><li><strong>Динамический выбор функции перехода</strong>: Использование различных эвристик для выбора следующего состояния в зависимости от характеристик задачи.</li></ol><ol type="1" id="b2808406-1a2d-412a-aaac-2b92440ed9f5" class="numbered-list" start="3"><li><strong>Мультистартовая стратегия</strong>: Запуск нескольких экземпляров алгоритма с различными начальными решениями для улучшения результатов.</li></ol><h3 id="3362fe3a-8df8-4186-acc7-6f5fcca23346" class="">Характеристики алгоритма имитации отжига:</h3><ol type="1" id="8216b499-4de9-41af-b7e0-6a2af2deef61" class="numbered-list" start="1"><li><strong>Способность к уходу из локальных оптимумов</strong>: Алгоритм имитации отжига имеет способность временно принимать худшие решения, что помогает ему избегать застревания в локальных оптимумах.</li></ol><ol type="1" id="1a9ce7f1-4835-4b54-9051-179654be08dc" class="numbered-list" start="2"><li><strong>Глобальность</strong>: Алгоритм имитации отжига является глобальным методом оптимизации, который может исследовать большое пространство поиска решений.</li></ol><ol type="1" id="6cee4f9d-f767-4c47-99b0-9fb71d5cf793" class="numbered-list" start="3"><li><strong>Настройка параметров</strong>: Эффективность алгоритма зависит от правильного выбора параметров, таких как начальная температура, коэффициенты охлаждения и вероятности принятия худших решений.</li></ol><ol type="1" id="708fc7fe-dbfe-4a34-a3ec-cb85a16485ee" class="numbered-list" start="4"><li><strong>Скорость сходимости</strong>: Время сходимости алгоритма может существенно зависеть от выбора параметров и сложности задачи.</li></ol></details></li></ul><ul id="cde576db-2efc-433d-86e5-9bab2303d5ec" class="toggle"><li><details open=""><summary>6. Муравьиный алгоритм, концепция алгоритма, шаги алгоритма, псевдокод</summary><p id="d9585738-0be0-4a35-ad86-e2868d33cbdf" class="">Муравьиный алгоритм (Ant Colony Optimization, ACO) - это алгоритм оптимизации, вдохновленный поведением реальных муравьев при поиске пути от гнезда к источнику пищи. Муравьи используют феромоны для отметки пути, и чем более успешен путь, тем больше феромонов на нем накапливается, что увеличивает вероятность выбора этого пути другими муравьями. </p><h3 id="8de1045e-91fe-4a09-9b31-8b351e72da1b" class="">Шаги алгоритма</h3><ol type="1" id="ec5d056e-137c-413b-b886-1aa79564556e" class="numbered-list" start="1"><li>Создается колония виртуальных муравьев, обычно количество муравьев делают равным количеству вершин в графе. Инициализируется стартовое положение каждого муравья. Все рёбра инициализируются начальным количеством феромона.</li></ol><ol type="1" id="d99ec511-0d62-4749-8e81-f55c5a3af1a3" class="numbered-list" start="2"><li>Муравьи отправляются в свободное путешествие. Муравей последовательно посещает вершины, пока не попадет в тупик или не дойдет до стартовой вершины. Решения муравья зависит от раскиданного феромона и расстояний до вершин.</li></ol><ol type="1" id="f91c895a-02e1-4494-97b8-ed078bcd51e3" class="numbered-list" start="3"><li>В зависимости от того, выполнил ли муравей поставленную задачу, напрямую зависит, будет ли он откладывать феромоны. Если задача не выполнена, то муравей не оставляет феромоны на своем пути, иначе муравей, в зависимости от длины своего пути, оставляет на своем пути феромоны. Это позволяет усилить путь для будущих муравьев и учитывать локальную информацию о качестве пути.</li></ol><ol type="1" id="749bbc47-ab41-4656-960b-ec8b77b34c8e" class="numbered-list" start="4"><li>Если муравей выполнил поставленную задачу, его путь и длина этого пути сохраняется (в том случае, если длина этого пути короче уже имеющегося).</li></ol><ol type="1" id="cf91686c-d1ed-4b59-be54-1a51fcb6dcca" class="numbered-list" start="5"><li>После того, как все муравьи завершат свою работу, делается глобальное обновление феромонов, которое учитывает локальное обновление феромона и испарение феромона.</li></ol><ol type="1" id="e8102db3-21bb-4b58-9753-24236c3702ac" class="numbered-list" start="6"><li>Процесс построения решений и обновления феромонов повторяется заданное количество раз или до достижения критерия остановки. После каждого прогона муравьев качество решения обычно улучшается.</li></ol><figure id="1c902a0e-55d4-4738-ba7e-df40f580bc8e" class="image"><a href="%D0%B7%D0%B0%D1%87%D0%B5%D1%82%E2%80%A6%20%D0%B2%20%D1%84%D0%BE%D1%80%D0%BC%D0%B5%E2%80%A6%20%D1%8D%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD%D0%B0%E2%80%A6%20b22bfe04330c4195bf345b7f5c484a70/Untitled%201.png"><img style="width:1390px" src="%D0%B7%D0%B0%D1%87%D0%B5%D1%82%E2%80%A6%20%D0%B2%20%D1%84%D0%BE%D1%80%D0%BC%D0%B5%E2%80%A6%20%D1%8D%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD%D0%B0%E2%80%A6%20b22bfe04330c4195bf345b7f5c484a70/Untitled%201.png"/></a></figure><p id="16822af5-f5c3-440e-8fe7-7b2cf143005e" class="">
</p></details></li></ul><ul id="789fcfda-9758-4df8-915f-ad201d23d9f1" class="toggle"><li><details open=""><summary>7. Муравьиный алгоритм, критерии окончания, выбора вершин, способы оценки качества решений, реализация испарения феромона</summary><h3 id="fe468833-dc45-4d6d-9aa4-f8e45fd059fc" class="">Критерии окончания</h3><ol type="1" id="08bff385-b82a-42a0-8577-87356fb399fe" class="numbered-list" start="1"><li><strong>Максимальное число итераций</strong></li></ol><ol type="1" id="445f47fc-7790-460c-b9e4-dbce9be90b3b" class="numbered-list" start="2"><li><strong>Максимальное время выполнения</strong></li></ol><ol type="1" id="1a73dba9-af8b-46ef-9cb3-d28f0f37447a" class="numbered-list" start="3"><li><strong>Сходимость</strong>: Алгоритм завершается, когда на протяжении определенного количества итераций не происходит значительных улучшений в качестве решений.</li></ol><ol type="1" id="960cb69b-4cfd-467b-b730-2784216a3e85" class="numbered-list" start="4"><li><strong>Качество решения</strong>: Алгоритм прекращает работу, когда найдено решение, качество которого превышает заранее заданный порог.</li></ol><p id="9e000242-c105-40cc-b26c-e77f7ea22f07" class="">Выбор вершин</p><figure id="b860bca2-5f97-4c26-9894-591e4be43b80" class="image"><a href="%D0%B7%D0%B0%D1%87%D0%B5%D1%82%E2%80%A6%20%D0%B2%20%D1%84%D0%BE%D1%80%D0%BC%D0%B5%E2%80%A6%20%D1%8D%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD%D0%B0%E2%80%A6%20b22bfe04330c4195bf345b7f5c484a70/Untitled%202.png"><img style="width:680px" src="%D0%B7%D0%B0%D1%87%D0%B5%D1%82%E2%80%A6%20%D0%B2%20%D1%84%D0%BE%D1%80%D0%BC%D0%B5%E2%80%A6%20%D1%8D%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD%D0%B0%E2%80%A6%20b22bfe04330c4195bf345b7f5c484a70/Untitled%202.png"/></a></figure><figure id="27d6f8d5-346b-4e13-8226-498f696c436c" class="image"><a href="%D0%B7%D0%B0%D1%87%D0%B5%D1%82%E2%80%A6%20%D0%B2%20%D1%84%D0%BE%D1%80%D0%BC%D0%B5%E2%80%A6%20%D1%8D%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD%D0%B0%E2%80%A6%20b22bfe04330c4195bf345b7f5c484a70/Untitled%203.png"><img style="width:1031px" src="%D0%B7%D0%B0%D1%87%D0%B5%D1%82%E2%80%A6%20%D0%B2%20%D1%84%D0%BE%D1%80%D0%BC%D0%B5%E2%80%A6%20%D1%8D%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD%D0%B0%E2%80%A6%20b22bfe04330c4195bf345b7f5c484a70/Untitled%203.png"/></a></figure><p id="1744093e-2da6-437c-b6fa-a3d3e9bde3c2" class="">
</p></details></li></ul><ul id="01650abf-a4f0-446d-b9a7-80c27d361cd9" class="toggle"><li><details open=""><summary>8. Муравьиная система, псевдокод, модификации муравьиной системы, характеристики</summary><p id="2a783310-bb6c-4195-8a6f-7caad816a5d8" class="">Муравьиная система - это алгоритм оптимизации, вдохновленный поведением муравьев при поиске оптимальных путей к источникам пищи. Она является одной из разновидностей муравьиного алгоритма и представляет собой более общий фреймворк для решения различных задач оптимизации.</p><h3 id="ea38f59f-9d46-43a0-be97-d8e5b83f5167" class="">Преимущества муравьиной системы:</h3><ul id="efeff025-7056-4d19-bee4-57ccac97ecd5" class="bulleted-list"><li style="list-style-type:disc"><strong>Параллелизм</strong>: Муравьи могут исследовать пространство решений независимо друг от друга, что позволяет использовать параллельные вычисления для ускорения процесса оптимизации.</li></ul><ul id="acf369fe-0bf8-478d-a808-d5d58c5ae739" class="bulleted-list"><li style="list-style-type:disc"><strong>Глобальность</strong>: Благодаря обмену информацией о качестве решений, муравьиная система способна обнаруживать лучшие решения даже в сложных пространствах поиска.</li></ul><ul id="c6709b83-75ed-4b55-a60d-067016ee3b1b" class="bulleted-list"><li style="list-style-type:disc"><strong>Адаптивность</strong>: Система способна адаптироваться к изменяющимся условиям и задачам, так как обновление феромонов происходит на основе текущих результатов оптимизации.</li></ul><p id="e74000a0-a9ab-4fad-8ee9-e2cc94c28a3d" class="">Муравьиная система эффективно применяется для решения различных задач оптимизации, включая задачу коммивояжера, маршрутизацию в сетях, задачи планирования и многие другие. Ее гибкость и эффективность делают ее популярным выбором для разнообразных прикладных задач.</p><p id="7577fb32-2f78-46c6-a247-75f6c6fd7cff" class=""><a href="https://www.notion.so/b0d5d1678fbd4d7080287120323cf8d8?pvs=21">24. Муравьиная система, псевдокод, модификации муравьиной системы, характеристики. (notion.so)</a></p></details></li></ul><ul id="d665be82-43a0-4498-b4ae-4ceea23787a4" class="toggle"><li><details open=""><summary>9. Двоичные деревья поиска. Основные операции над двоичными деревьями поиска</summary><p id="5ce83cdb-30de-4717-aa8a-7837838446ba" class=""><strong>Двоичное дерево поиска </strong>— двоичное дерево, для которого выполняются следующие дополнительные условия (<em>свойства дерева поиска</em>):</p><ul id="2d12c422-9d2b-4091-893c-aeb82b900edc" class="bulleted-list"><li style="list-style-type:disc">оба поддерева — левое и правое — являются двоичными деревьями поиска;</li></ul><ul id="8102bb71-afcc-4b43-b6d9-9742c477605d" class="bulleted-list"><li style="list-style-type:disc">у всех узлов <em>левого</em> поддерева произвольного узла X значения ключей данных <em>меньше либо равны</em>, нежели значение ключа данных самого узла X;</li></ul><ul id="d0e4e915-40f6-47cc-b43a-3d0d10ef9539" class="bulleted-list"><li style="list-style-type:disc">у всех узлов <em>правого</em> поддерева произвольного узла X значения ключей данных <em>больше</em>, нежели значение ключа данных самого узла X.</li></ul><p id="202baec1-0923-49c6-8a47-812d95b5e8b0" class="">Данные в каждом узле должны обладать ключами, на которых определена операция сравнения <em>меньше</em>.</p><h3 id="5e36f37a-47d0-4575-bd6d-ba1aff8fa9dd" class="">Основные операции над двоичными деревьями поиска:</h3><ol type="1" id="b0d8418f-5582-477f-b54a-47c0eb1d9e05" class="numbered-list" start="1"><li><strong>Вставка (Insertion)</strong>:<ul id="a97a2338-0c30-4282-a7d4-d7a97cf50591" class="bulleted-list"><li style="list-style-type:disc">Позволяет добавить новый элемент в дерево. Новый элемент сравнивается с каждым узлом, начиная с корня. Если значение нового элемента меньше значения текущего узла, оно идет влево, если больше - вправо. Этот процесс повторяется до тех пор, пока не будет найдено место для вставки нового элемента.</li></ul></li></ol><ol type="1" id="14711b89-2cb6-411f-a8fb-1cde0e28baaf" class="numbered-list" start="2"><li><strong>Удаление (Deletion)</strong>: Позволяет удалить элемент из дерева. Существуют различные случаи, которые нужно учитывать при удалении:<ul id="b767eb0d-9237-4006-9bd2-9b0d40e340fa" class="bulleted-list"><li style="list-style-type:disc">У удаляемого узла нет потомков: удаляем его просто.</li></ul><ul id="8ac9c2ef-d52e-4c11-be6e-7ab516ab656f" class="bulleted-list"><li style="list-style-type:disc">У удаляемого узла есть один потомок: заменяем удаляемый узел на его потомка.</li></ul><ul id="63800128-9b48-4439-8cee-4949d683188a" class="bulleted-list"><li style="list-style-type:disc">У удаляемого узла есть два потомка: находим наименьший элемент в правом поддереве (или наибольший в левом поддереве), копируем его ключ в удаляемый узел и удаляем этот наименьший (наибольший) элемент.</li></ul></li></ol><ol type="1" id="a10e42b0-9661-4b92-9b09-6fd1522abd7d" class="numbered-list" start="3"><li><strong>Поиск (Search)</strong>:<ul id="b84e2d0b-9737-40fb-ae60-cabeb20e832b" class="bulleted-list"><li style="list-style-type:disc">Позволяет найти элемент с заданным ключом в дереве.</li></ul><ul id="24c61284-e789-48c8-a884-81902999f241" class="bulleted-list"><li style="list-style-type:disc">Поиск начинается с корня.</li></ul><ul id="d0532c1c-269a-4117-9613-54afdd99c66e" class="bulleted-list"><li style="list-style-type:disc">Если ключ текущего узла совпадает с искомым, операция завершается успехом.</li></ul><ul id="7c7fbb25-235f-4acc-987c-3b7e30d3aa26" class="bulleted-list"><li style="list-style-type:disc">Если ключ меньше значения текущего узла, поиск продолжается в левом поддереве; если больше - в правом.</li></ul><ul id="8f391d81-3f0a-43e5-904f-0f04eca0c7fd" class="bulleted-list"><li style="list-style-type:disc">Если достигнут конец дерева и элемент не найден, операция завершается неудачей.</li></ul></li></ol><ol type="1" id="261f371e-9630-4e5f-a4f2-986f94a8a77d" class="numbered-list" start="4"><li><strong>Поиск минимума/максимума</strong>:<ul id="f528551c-cd5d-44aa-be79-90ddb239b3d0" class="bulleted-list"><li style="list-style-type:disc">Минимальный элемент в дереве находится в самом левом узле.</li></ul><ul id="922645dc-81b3-4d15-a5bc-6d05e17e5816" class="bulleted-list"><li style="list-style-type:disc">Максимальный элемент в дереве находится в самом правом узле.</li></ul></li></ol></details></li></ul><ul id="3ffc9fa9-af7a-4617-8eba-4ec1410710c1" class="toggle"><li><details open=""><summary>10. Деревья. Алгоритмы обхода дерева (BFS, DFS)</summary><h3 id="3c2077bb-056a-4919-a822-f45ec9f8cfce" class="">Деревья:</h3><p id="e318ab0b-2fb9-48c4-a08d-a9fad9d9107d" class="">Дерево - это иерархическая структура данных, состоящая из узлов, соединенных ребрами. Каждый узел имеет родительский узел (за исключением корневого узла) и ноль или более дочерних узлов.</p><p id="23330c7c-3d39-40ca-bf0d-c95fc41e1da0" class="">DFS (Depth-First Search): DFS - это алгоритм обхода графа или дерева, который начинает с корневого узла и следует по одной ветви дерева до тех пор, пока не достигнет конца этой ветви, а затем возвращается и продолжает поиск в других ветвях. Он использует стек для хранения узлов, которые нужно посетить. LIFO</p><p id="2b64a98e-c632-4fcc-86bb-81865a420af8" class=""><strong>Принцип работы:</strong></p><ol type="1" id="151d0a8a-e3bc-4528-a96c-1ec350b78dbb" class="numbered-list" start="1"><li>Начать с корневого узла и поместить его в стек.</li></ol><ol type="1" id="497db455-66df-4284-8e87-5702ee371baf" class="numbered-list" start="2"><li>Извлечь узел из стека, посетить его и поместить всех его непосещенных дочерних узлов в стек.</li></ol><ol type="1" id="78a56436-56ff-40c7-a462-48e559335346" class="numbered-list" start="3"><li>Повторять шаг 2 до тех пор, пока стек не станет пустым.</li></ol><h3 id="d964845a-8050-4032-b418-31cc77f267fd" class="">1. BFS (Breadth-First Search):</h3><p id="84a7159d-3ad0-489e-8ea8-dcac4429f4fe" class="">BFS - это алгоритм обхода графа или дерева, который начинает с корневого узла и посещает все узлы на одном уровне перед переходом к следующему уровню. Он использует очередь для хранения узлов, которые нужно посетить. FIFO</p><p id="f6a54798-f906-45fa-9277-3611d941a44e" class=""><strong>Принцип работы:</strong></p><ol type="1" id="d8793085-07dc-4ad9-9b6f-69b3d449ea60" class="numbered-list" start="1"><li>Начать с корневого узла и поместить его в очередь.</li></ol><ol type="1" id="3d9324de-2bf4-48fa-ad9e-03f99ab5a60b" class="numbered-list" start="2"><li>Извлечь узел из очереди и посетить его.</li></ol><ol type="1" id="911b0955-c19e-4f64-b13d-ce3fc879a3bc" class="numbered-list" start="3"><li>Поместить всех его не посещенных дочерних узлов в очередь.</li></ol><ol type="1" id="ed57ec4a-fa6a-40b2-8d3e-a1989403a25a" class="numbered-list" start="4"><li>Повторять шаги 2-3 до тех пор, пока очередь не станет пустой.</li></ol><p id="6b2f2871-3643-4f9c-ad12-fdc8ec68a37d" class="">Недостатки: BFS может быть менее эффективным при поиске в глубоких деревьях или графах, DFS может зациклиться в графах с циклами.</p></details></li></ul><ul id="d9d9afff-ed9c-41ba-b663-425297716511" class="toggle"><li><details open=""><summary>11. Алгоритм создания упорядоченного бинарного дерева.</summary><p id="8c66c07b-4b7e-4691-80d6-a627fda2747c" class=""><strong>Двоичное дерево поиска </strong>— двоичное дерево, для которого выполняются следующие дополнительные условия (<em>свойства дерева поиска</em>):</p><ul id="5c1f512d-4add-439c-a745-1b45de2f29a5" class="bulleted-list"><li style="list-style-type:disc">оба поддерева — левое и правое — являются двоичными деревьями поиска;</li></ul><ul id="94cdd1ea-3fcf-45e2-a31a-cfbb3312522a" class="bulleted-list"><li style="list-style-type:disc">у всех узлов <em>левого</em> поддерева произвольного узла X значения ключей данных <em>меньше либо равны</em>, нежели значение ключа данных самого узла X;</li></ul><ul id="823bd907-9f7e-46a0-b610-cc1872a9136f" class="bulleted-list"><li style="list-style-type:disc">у всех узлов <em>правого</em> поддерева произвольного узла X значения ключей данных <em>больше</em>, нежели значение ключа данных самого узла X.</li></ul><p id="4b86d96c-63ec-48a6-8662-f755164f8778" class="">Данные в каждом узле должны обладать ключами, на которых определена операция сравнения <em>меньше</em>.</p><h3 id="5ad83703-e667-4c0c-8ebd-2d58dfc1dad1" class="">Алгоритм создания упорядоченного бинарного дерева</h3><p id="b4adb81e-185f-4bd3-9b96-d293f07151c8" class="">Создание упорядоченного бинарного дерева из неупорядоченного набора данных осуществляется последовательной вставкой каждого элемента в дерево.</p><h3 id="59783d0b-5006-4d02-961b-d85a08422d48" class="">Пошаговый алгоритм:</h3><ol type="1" id="068bee51-6d9e-4029-a917-f5c51c501c52" class="numbered-list" start="1"><li><strong>Инициализация дерева</strong>:<ul id="69fe354c-e938-4b8f-87a7-a5f6719a60c9" class="bulleted-list"><li style="list-style-type:disc">Создать пустое дерево. Корневой узел (root) установлен в значение null.</li></ul></li></ol><ol type="1" id="cfbceeed-5025-4391-882f-fef34d7a4114" class="numbered-list" start="2"><li><strong>Вставка элемента</strong>:<ul id="73bf0f5f-1ac3-40af-aaee-b95c33aaae94" class="bulleted-list"><li style="list-style-type:disc">Для каждого элемента в наборе данных:<ol type="1" id="68d0338d-3f58-4d0f-bdaa-8e05223ce80d" class="numbered-list" start="1"><li>Если дерево пустое, новый элемент становится корневым узлом.</li></ol><ol type="1" id="79ceb76d-9893-457a-b366-1b6e98c46693" class="numbered-list" start="2"><li>В противном случае, сравнить новый элемент с корневым узлом:<ul id="549a52fa-f734-4465-90cb-b11a22408bf3" class="bulleted-list"><li style="list-style-type:disc">Если новый элемент меньше корневого узла, перейти к левому поддереву.</li></ul><ul id="52ad6d01-18e3-4155-8be0-e33752ac2114" class="bulleted-list"><li style="list-style-type:disc">Если новый элемент больше корневого узла, перейти к правому поддереву.</li></ul></li></ol><ol type="1" id="fc9c175f-24d4-475d-b289-0fa667f95380" class="numbered-list" start="3"><li>Повторять сравнение и переход к левому или правому поддереву, пока не будет найдено подходящее место для нового элемента.</li></ol><ol type="1" id="a3e4db1a-cc62-45f6-b709-bb0c3fd8da07" class="numbered-list" start="4"><li>Вставить новый элемент в найденное место.</li></ol></li></ul></li></ol><p id="4cf04412-8cae-47af-be3f-c18f5cd58679" class="">Преимущества включают эффективность операций поиска, вставки и удаления с средней временной сложностью \(O(\log n)\) для сбалансированных деревьев. Недостатки - возможная деградация до временной сложности \(O(n)\) в случае несбалансированных деревьев.</p></details></li></ul><ul id="622b89b1-76b0-4562-aad2-382f7df7ae56" class="toggle"><li><details open=""><summary>12. Поиск по бинарному дереву. Эффективность поиска по бинарному дереву.</summary><p id="ad50f49f-f030-4532-92bf-02ab23feffae" class=""><strong>Двоичное дерево поиска </strong>— двоичное дерево, для которого выполняются следующие дополнительные условия (<em>свойства дерева поиска</em>):</p><ul id="acd36163-5f9a-435d-8ff4-3eb30433603a" class="bulleted-list"><li style="list-style-type:disc">оба поддерева — левое и правое — являются двоичными деревьями поиска;</li></ul><ul id="4495b26c-ccab-4a7e-8081-bd438468617b" class="bulleted-list"><li style="list-style-type:disc">у всех узлов <em>левого</em> поддерева произвольного узла X значения ключей данных <em>меньше либо равны</em>, нежели значение ключа данных самого узла X;</li></ul><ul id="0de2afc3-39ba-4160-bc3f-dfef9c85e683" class="bulleted-list"><li style="list-style-type:disc">у всех узлов <em>правого</em> поддерева произвольного узла X значения ключей данных <em>больше</em>, нежели значение ключа данных самого узла X.</li></ul><p id="769b9a92-9284-40d5-9515-6b5397614fb6" class="">Данные в каждом узле должны обладать ключами, на которых определена операция сравнения <em>меньше</em>.</p><h3 id="1e8598cc-2c8a-4b6c-81e9-40972bfc8974" class="">Алгоритм поиска по бинарному дереву</h3><p id="c97e90bb-ee75-4348-9587-be6d67c83a75" class="">Поиск элемента в бинарном дереве поиска основан на сравнении ключа искомого элемента с ключами узлов дерева, начиная с корневого узла.</p><h3 id="f2d49344-6fb5-45d9-8421-5e7e0c295c4e" class="">Пошаговый алгоритм:</h3><ol type="1" id="29b31265-1df6-4660-9ed6-ff63e830e1dc" class="numbered-list" start="1"><li>Начать с корневого узла.</li></ol><ol type="1" id="79568702-8abf-48ad-b6d5-9f34fe44aad5" class="numbered-list" start="2"><li>Сравнить ключ искомого элемента с ключом текущего узла:<ul id="b3ee4d86-b69a-41e7-b23f-01c45aeacfd9" class="bulleted-list"><li style="list-style-type:disc">Если ключ совпадает, элемент найден.</li></ul><ul id="8a57d99a-b6d2-4f6b-be7b-942f82b0dc40" class="bulleted-list"><li style="list-style-type:disc">Если ключ меньше, перейти к левому поддереву.</li></ul><ul id="47ee074b-a6c9-4db5-9f46-57e1749d6616" class="bulleted-list"><li style="list-style-type:disc">Если ключ больше, перейти к правому поддереву.</li></ul></li></ol><ol type="1" id="deab76cf-bc03-488c-a1cd-cb2e33fcfa55" class="numbered-list" start="3"><li>Повторять шаг 2 до тех пор, пока элемент не будет найден или не будет достигнут листовой узел (узел без потомков).</li></ol><ol type="1" id="1030340c-de03-4cfb-9e7e-adfae34c22f1" class="numbered-list" start="4"><li>Если достигнут листовой узел и элемент не найден, он отсутствует в дереве.</li></ol><h3 id="3dd43f5c-d4e4-4270-b611-977e2578409c" class="">Эффективность поиска</h3><p id="21923b85-3858-4c8b-8015-e78899962ad2" class="">Эффективность поиска в бинарном дереве поиска определяется его высотой.</p><h3 id="3b0f525b-cbea-4428-af26-54c8753d11fa" class="">Временная сложность:</h3><ul id="08b59622-08ec-4237-b179-cc06c5f95194" class="bulleted-list"><li style="list-style-type:disc"><strong>Лучший случай</strong>: Когда дерево сбалансировано (идеально), высота дерева \( h \) составляет \( O(\log n) \), где \( n \) — количество узлов. В этом случае временная сложность поиска \( O(\log n) \).</li></ul><ul id="871e4c27-9554-4cc6-a7c2-fef000ecf4ec" class="bulleted-list"><li style="list-style-type:disc"><strong>Худший случай</strong>: Когда дерево представляет собой вырожденное дерево (например, все элементы вставлены в возрастающем или убывающем порядке), высота дерева \( h \) составляет \( O(n) \). В этом случае временная сложность поиска \( O(n) \).</li></ul></details></li></ul><ul id="f49dd6f7-049a-4eb1-8829-974a76b8fc98" class="toggle"><li><details open=""><summary>13. Операции. Красно-черные деревья. Свойства и особенности.</summary><p id="b10eeb31-61c8-4cd1-ba4a-89c465489aea" class="">Красно-черное дерево — это вид самобалансирующегося двоичного дерева поиска, в котором каждый узел имеет дополнительное свойство — цвет, который может быть либо красным, либо черным. Красно-черные деревья используются для обеспечения логарифмической высоты дерева, что позволяет эффективно выполнять операции поиска, вставки и удаления.</p><h3 id="c8618b36-bb21-4d5e-b636-5ca217b97134" class="">Свойства красно-черного дерева</h3><ol type="1" id="20557c36-ae09-46d6-96fe-162b84a7ef14" class="numbered-list" start="1"><li><strong>Каждый узел окрашен в красный или черный цвет.</strong></li></ol><ol type="1" id="29b33ecc-588f-42fa-9b8a-472259417fc7" class="numbered-list" start="2"><li><strong>Корневой узел всегда черный.</strong></li></ol><ol type="1" id="ff3c24d6-3a5f-4891-adbf-ed373af27784" class="numbered-list" start="3"><li><strong>Все листья (nil или NULL узлы) считаются черными.</strong></li></ol><ol type="1" id="55a1e9a5-04a7-400d-9171-50981824627d" class="numbered-list" start="4"><li><strong>Если узел красный, оба его дочерних узла должны быть черными (не может быть двух последовательных красных узлов).</strong></li></ol><ol type="1" id="14d87380-0031-4831-9a29-45145f3ec797" class="numbered-list" start="5"><li><strong>Для каждого узла путь от него до всех его потомков-листьев содержит одинаковое количество черных узлов.</strong></li></ol><p id="1cf1a1cb-5657-4907-958b-4c2c59eb9618" class="">Эти свойства обеспечивают балансировку дерева, поддерживая его высоту на уровне \(O(\log n)\).</p><h3 id="24b2e3b6-0c16-4d10-ae91-3d317e9fdad3" class="">1. <strong>Поиск</strong></h3><p id="2d3b22a9-8337-458d-8aeb-f3a2313a69cf" class="">Алгоритм поиска в красно-черном дереве аналогичен алгоритму поиска в обычном двоичном дереве поиска. Временная сложность составляет \(O(\log n)\) из-за сбалансированности дерева.</p><ol type="1" id="dc562fb4-9dc7-4fd7-8fdc-da5283adb521" class="numbered-list" start="2"><li><strong>Вставка</strong></li></ol><p id="4e265433-2a91-4a16-85e2-b139d043e6bd" class="">Вставка нового узла в красно-черное дерево требует дополнительных шагов для поддержания его свойств:</p><ol type="1" id="daf401bb-2494-4c25-9a99-38aa13b1dbbd" class="numbered-list" start="1"><li>Новый узел всегда вставляется как красный.</li></ol><ol type="1" id="62710237-ab30-44e1-b321-6e6315e52b0c" class="numbered-list" start="2"><li>Если родитель нового узла черный, дерево остается корректным.</li></ol><ol type="1" id="33982970-f66c-4d97-825c-a9e6e7d43362" class="numbered-list" start="3"><li>Если родитель нового узла красный, необходимо выполнять ребалансировку.</li></ol><h3 id="5a31a974-1670-4310-8795-3192771f6050" class="">3. <strong>Удаление</strong></h3><p id="ba0d577f-823b-492c-a14b-6e4e234bd680" class="">Удаление узла в красно-черном дереве также требует ребалансировки для сохранения свойств дерева. Основные шаги удаления:</p><ol type="1" id="d130774e-8c1c-4c1a-8aeb-1559509d0404" class="numbered-list" start="1"><li>Найти узел для удаления.</li></ol><ol type="1" id="64b3b2bc-2976-47e0-8a42-84efe66ab8a2" class="numbered-list" start="2"><li>Удалить узел, заменив его подходящим потомком (если он имеет два потомка, то наименьшим элементом из правого поддерева).</li></ol><ol type="1" id="442c9464-6774-41b7-bf7a-e75a962ac397" class="numbered-list" start="3"><li>Выполнить ребалансировку, если удаление нарушает свойства красно-черного дерева.</li></ol></details></li></ul><ul id="6d18ff94-9d22-438b-9f80-30377f651ac7" class="toggle"><li><details open=""><summary>14. AVL-деревья. Основные операции над AVL-деревьями.</summary><p id="18fdcbfc-0540-408b-b0fc-81266cbbb943" class=""><strong>АВЛ-дерево</strong> — сбалансированное по высоте <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0">двоичное дерево поиска</a>: для каждой его вершины высота её двух поддеревьев различается не более чем на 1.<br/><br/>Свойства AVL-дерева<br/></p><ol type="1" id="e1d65ed4-db75-4122-8450-ac1ba985aa0c" class="numbered-list" start="1"><li><strong>Балансировка узлов</strong>: Для любого узла разница высоты его левого и правого поддеревьев (баланс-фактор) может быть только -1, 0 или 1.</li></ol><ol type="1" id="527ded3e-1227-4030-b100-3111b0f25053" class="numbered-list" start="2"><li><strong>Балансировка поддерживается автоматически</strong>: После каждой операции вставки или удаления выполняются операции балансировки (повороты).</li></ol><p id="cf9650d2-aecc-4718-a62d-4c87f7b09ef8" class="">Основные операции над AVL-деревьями</p><h3 id="922ab4ba-3918-40e9-80fb-6dfa413f1038" class="">1. <strong>Поиск</strong></h3><p id="3dedb4ce-e36d-4691-a733-f9c11895ccd4" class="">Поиск в AVL-дереве аналогичен поиску в обычном двоичном дереве поиска. Он начинается с корневого узла и движется по дереву в зависимости от значения ключа.</p><h3 id="cc95f62e-dd18-447d-ba47-793463caad2d" class="">2. <strong>Вставка</strong></h3><p id="bc44db71-0890-43fa-8752-3b244563597c" class="">Вставка в AVL-дерево включает два основных шага:</p><ul id="103e4895-2702-4041-908a-d44b12d23680" class="bulleted-list"><li style="list-style-type:disc">Вставка нового узла как в обычном бинарном дереве поиска.</li></ul><ul id="ce1edb3b-9331-4b29-a940-fc929547a195" class="bulleted-list"><li style="list-style-type:disc">Восстановление балансировки дерева, если она была нарушена. Тут тоже через повороты</li></ul><h3 id="4500d3df-b26b-4234-916f-a6b2a426bef4" class="">3. <strong>Удаление</strong></h3><ul id="22ed71b7-7d8a-4f86-889f-a019adaf6af9" class="bulleted-list"><li style="list-style-type:disc">Удаление узла как в обычном бинарном дереве поиска.</li></ul><ul id="a360604e-39bf-4eef-9ac5-efc62d608649" class="bulleted-list"><li style="list-style-type:disc">Восстановление балансировки, если она нарушена.</li></ul><h3 id="97e3dc7b-b68a-4e18-af64-188c596c6705" class="">Характеристики AVL-деревьев</h3><ol type="1" id="ae9e5aaf-d6fc-4872-bccd-62cad55f043a" class="numbered-list" start="1"><li><strong>Высота дерева</strong>: \(O(\log n)\)</li></ol><ol type="1" id="62969e37-8c59-44c3-9cf7-0c4cf0155cdf" class="numbered-list" start="2"><li><strong>Сложность операций</strong>:<ul id="6f8bcbea-9a89-4332-a34e-bbd33d3f43ce" class="bulleted-list"><li style="list-style-type:disc">Поиск: \(O(\log n)\)</li></ul><ul id="b73d1b21-13a5-4171-958f-842060236de0" class="bulleted-list"><li style="list-style-type:disc">Вставка: \(O(\log n)\)</li></ul><ul id="a4659bba-11f2-4afb-8e86-8952eb20770e" class="bulleted-list"><li style="list-style-type:disc">Удаление: \(O(\log n)\)</li></ul></li></ol><ol type="1" id="4c3f64bb-fb22-4f29-8281-afb7b0fc6249" class="numbered-list" start="3"><li><strong>Строгая балансировка</strong>: AVL-деревья обеспечивают лучшую балансировку по сравнению с красно-черными деревьями, что делает их более эффективными для операций поиска.</li></ol></details></li></ul><ul id="25b47983-1418-4c76-89dd-4824534edac5" class="toggle"><li><details open=""><summary>15. Обработка изображения, концепция алгоритма,</summary><p id="4ece5e95-95b0-4409-8616-4bfe7a3b2c50" class="">Основная идея метода в проекции в собственные подпространства как одного из инструментов математической обработки наблюдений и инструмента выявления и/или установления связей в наблюдениях.</p><p id="bfd791e1-bfa5-40fe-ad95-1ecb55769e1d" class="">Детальной разработки канонического корреляционного анализа (Canonical Correlation<br/>Analysis – ССА) и частичных наименьших квадратов (Partial Least Squares – PLS), как методов проекции в общее собственное подпространство для двух и более<br/>наборов исходных данных.<br/></p><p id="2688ef2b-cf51-4867-ad05-e650712437c6" class="">Все упомянутые выше методы проекции в собственное подпространство реализуются в два последовательных этапа. Первый этап включает построение<br/>собственного базиса для исходных данных и выбор<br/>главных компонент. Наибольшие вычислительные затраты здесь связаны с решением задач на собственные значения. И если размерность исходного пространства признаков равна D, то сначала вычисляются необходимые матрицы ковариации и общие матрицы рассеяния (в соответствии с требуемым критерием), порядок которых равен D, а потом вычисляются D собственных чисел и D соответствующих им<br/>собственных векторов, а также определяются d главных компонент (d &lt;&lt; D). В общем случае вычислительные затраты здесь составляют O1 ≅ D3<br/>На втором этапе реализуется проекция исходных<br/>данных в собственное подпространство (как преобразование в собственном базисе или преобразование<br/>Карунена–Лоэва) и выполняется редукция размерности пространства признаков до значений d. При этом<br/>вычислительные затраты здесь составляют O2 ≤ D2<br/></p><p id="5ef85478-8f23-44b7-b0e3-a09af19a4c05" class="">Наконец, следует отметить, что при «искусственной<br/>векторизации» изображений в векторах не сохраняются пространственные отношения соседних элементов. При этом утрачивается и возможность полного<br/>использования корреляции, имеющейся в исходных<br/>матрицах между соседними элементами.<br/>Естественно, что эти проблемы – невозможность<br/>использования РСА для изображений при граничных<br/>значениях базовых параметров, потеря информации и<br/>утрата полного использования корреляции между исходными элементами – касается также методов LDA,<br/>PLS и ССА.<br/>Однако решение этой проблемы неожиданно появилось в 1998 году при новом подходе к реализации<br/>преобразования Карунена–Лоэва в приложении к<br/>изображениям лиц. Подход был назван «Vector Based<br/>Approximation of KLT» – VKLT [8]. Основная его<br/>идея состоит в том, что в отличие от [2, 5, 6] в VKLT<br/>вычисляются две матрицы ковариации C0 и R0, которые определяются отдельно по столбцам и строкам<br/>всех исходных изображений без их конкатенации в<br/>вектор. Далее вычисляются две матрицы проекции Φ1<br/>и Φ2, определяемые собственными векторами матриц<br/>ковариации C0 и R0. Проекция исходных изображений<br/>в новое пространство признаков реализуется как двумерное (по строкам и столбцам) преобразование Карунена–Лоэва так, что<br/>T k k Ф Ф 1 2 Y X = , для всех k = 1, 2, …K, (2)<br/>где Xk, Yk – изображение и его проекция в собственном подпространстве, что и отличает подход [8] от [2,<br/>5 – 6]. Заметим, что в (2) исходное изображение Xk и<br/>его проекция Yk в подпространстве представлены<br/>матрицами размера M×N.<br/></p></details></li></ul><ul id="3adfa514-34b8-4023-a99e-a9bda2fbdd73" class="toggle"><li><details open=""><summary>16. Алгоритм 2D ССА, каскадный и параллельный </summary><p id="8f1de30c-4015-4ae0-ad60-93a3438973e9" class="">Методы CCA и PLS позволяют отобразить два набора исходных данных (часто не коррелированных,<br/>или внешне подобных, но семантически не связанных<br/>между собой) в общее собственное подпространство<br/>признаков, в котором они сильно коррелируют. Это<br/>позволяет связать пары исходных данных в собственном подпространстве с помощью общей регрессионной модели, чтобы представлять и понимать одни наблюдения, действия (или явления) через другие, устраняя тем самым полностью или частично сенсорный<br/>или семантический разрыв между ними.<br/></p><ul id="64eae48e-e5c5-4969-b9d5-b95b3ae04d24" class="toggle"><li><details open=""><summary>16) Алгоритм	2D ССА, каскадный и параллельный</summary><figure id="11606274-5101-44e6-b522-55ad780dfa8f" class="image"><a href="%D0%B7%D0%B0%D1%87%D0%B5%D1%82%E2%80%A6%20%D0%B2%20%D1%84%D0%BE%D1%80%D0%BC%D0%B5%E2%80%A6%20%D1%8D%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD%D0%B0%E2%80%A6%20b22bfe04330c4195bf345b7f5c484a70/Untitled%204.png"><img style="width:652px" src="%D0%B7%D0%B0%D1%87%D0%B5%D1%82%E2%80%A6%20%D0%B2%20%D1%84%D0%BE%D1%80%D0%BC%D0%B5%E2%80%A6%20%D1%8D%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD%D0%B0%E2%80%A6%20b22bfe04330c4195bf345b7f5c484a70/Untitled%204.png"/></a></figure><figure id="44ec9c3a-85d5-4f17-bd0b-04bcde432805" class="image"><a href="%D0%B7%D0%B0%D1%87%D0%B5%D1%82%E2%80%A6%20%D0%B2%20%D1%84%D0%BE%D1%80%D0%BC%D0%B5%E2%80%A6%20%D1%8D%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD%D0%B0%E2%80%A6%20b22bfe04330c4195bf345b7f5c484a70/Untitled%205.png"><img style="width:652px" src="%D0%B7%D0%B0%D1%87%D0%B5%D1%82%E2%80%A6%20%D0%B2%20%D1%84%D0%BE%D1%80%D0%BC%D0%B5%E2%80%A6%20%D1%8D%D0%BA%D0%B7%D0%B0%D0%BC%D0%B5%D0%BD%D0%B0%E2%80%A6%20b22bfe04330c4195bf345b7f5c484a70/Untitled%205.png"/></a></figure></details></li></ul><h3 id="fbc58c23-f310-4746-bc40-f732b449b65a" class="">Основные различия между каскадным и параллельным алгоритмом:</h3><ol type="1" id="e6b9d512-de2a-414d-8dd5-b911e68ba74e" class="numbered-list" start="1"><li><strong>Последовательность выполнения</strong>:<ul id="7c04ac3a-d58c-45d9-b8d0-7deee8085be7" class="bulleted-list"><li style="list-style-type:disc">Параллельный алгоритм выполняет вычисления матриц ковариации и решение задач на собственные значения одновременно (или параллельно).</li></ul><ul id="ca3d61d4-ceec-474d-81c4-ed9188211cd8" class="bulleted-list"><li style="list-style-type:disc">Каскадный алгоритм сначала решает задачу на собственные значения для строк, затем использует промежуточные результаты для столбцов.</li></ul></li></ol><ol type="1" id="2edc4c14-7aaf-4dbc-b3b5-9c7dd186143c" class="numbered-list" start="2"><li><strong>Вычислительные этапы</strong>:<ul id="2e579931-ee4d-472c-b0fb-9a173ede0b99" class="bulleted-list"><li style="list-style-type:disc">В параллельном алгоритме матрицы ковариации C(r) и C(c) вычисляются и решаются одновременно, что может требовать больше ресурсов.</li></ul><ul id="da89cbd5-6930-4677-b37c-b388fb80de58" class="bulleted-list"><li style="list-style-type:disc">В каскадном алгоритме задачи решаются последовательно, что может быть более эффективным по памяти и вычислительным затратам, но потенциально медленнее из-за зависимости шагов друг от друга.</li></ul></li></ol><ol type="1" id="aeb367e8-64fd-4016-8caa-853eeeab5712" class="numbered-list" start="3"><li><strong>Проекция данных</strong>:<ul id="c11c48d4-2de3-4466-ae28-932e0adeaea3" class="bulleted-list"><li style="list-style-type:disc">В параллельном алгоритме проекция выполняется один раз после определения обоих наборов собственных векторов.</li></ul><ul id="94bf2dc1-0bc3-4873-bbe1-4c068f1266fd" class="bulleted-list"><li style="list-style-type:disc">В каскадном алгоритме проекция выполняется дважды: сначала в промежуточное пространство после первой задачи, затем в конечное после второй.</li></ul></li></ol><p id="1f7c17b6-e4fe-4464-8db5-a9867660c8cd" class="">Эти различия отражают разные подходы к оптимизации и вычислительным затратам при выполнении 2DPCA/2DKLT.</p></details></li></ul><ul id="cd4569ad-6fd2-40cf-8add-40bfd07afdd9" class="toggle"><li><details open=""><summary>17. Методы PLS и CCA</summary><h3 id="8b3a5fdf-6ee8-46d2-af89-82377211aaec" class="">Введение</h3><p id="49ab3370-8b21-4671-9b71-a54b558d264d" class="">PLS (Partial Least Squares) и CCA (Canonical Correlation Analysis) — это два статистических метода, используемых для анализа многомерных данных. Оба метода используются для выявления и моделирования связей между двумя наборами переменных, но они делают это по-разному.</p><h3 id="760d615a-d5c4-4985-8b5e-3d28320063fb" class="">Partial Least Squares (PLS)</h3><p id="472f6ba9-da45-49a5-9550-6096cea401d1" class="">PLS — это метод, который используется для моделирования взаимозависимостей между наборами наблюдаемых переменных. Он сочетает в себе черты методов регрессии и анализа главных компонент (PCA).</p><h3 id="bc123a3b-b250-4710-b4d9-dc6752fa8401" class="">Концепция PLS</h3><p id="47abdd2d-bde7-473d-9ffe-deb8b8902d1e" class="">Цель PLS — найти такие проекции X и Y, которые максимизируют ковариацию между ними, при этом сохраняя как можно больше информации об исходных данных.</p><h3 id="085758d8-9cca-4038-8c7e-8bbfdf4e39d4" class="">Шаги алгоритма PLS</h3><ol type="1" id="8f2ccef8-7edc-4ee5-a362-43736744192c" class="numbered-list" start="1"><li><strong>Центрирование данных</strong>: Средние значения всех переменных вычитаются из данных.</li></ol><ol type="1" id="4766a498-e357-4b60-a639-70bbfc65e1ab" class="numbered-list" start="2"><li><strong>Итеративный процесс</strong>:<ul id="09247f63-fe8a-4e59-a3b6-02881f7a9dda" class="bulleted-list"><li style="list-style-type:disc">Вычисление весов для каждого набора переменных.</li></ul><ul id="870b9323-21f5-421b-9e2d-4d27c262e836" class="bulleted-list"><li style="list-style-type:disc">Проекция данных на найденные веса для получения новых компонентов.</li></ul><ul id="8680f0a4-53a6-4665-b3af-350f6353040d" class="bulleted-list"><li style="list-style-type:disc">Оценка остаточных матриц и обновление весов до тех пор, пока не будет достигнута сходимость.</li></ul><p id="25b90680-d263-4492-bfb2-e7aa2aa8287a" class="">
</p><h3 id="5c5e7547-fa32-4ecf-ac1c-29bce09b5e0f" class="">Canonical Correlation Analysis (CCA)</h3><p id="76e329f4-74d7-451d-b646-a9e33ddbae7b" class="">CCA — это метод, используемый для анализа взаимосвязей между двумя наборами многомерных переменных. Он ищет линейные комбинации переменных в каждом наборе, которые максимально коррелируют между собой.</p><h3 id="19c403c3-1740-43b0-a070-4e62cea90c6f" class="">Концепция CCA</h3><p id="c37cd18e-f2b1-4950-b608-a1db8694f8c1" class="">Цель CCA — найти такие векторы \( a \) и \( b \), что корреляция между линейными комбинациями \( X \) и \( Y \), \( U = Xa \) и \( V = Yb \), максимальна.</p><h3 id="ae8f99db-8d6e-4f68-9331-9d8859615ad6" class="">Шаги алгоритма CCA</h3><ol type="1" id="7b9aa745-f1e2-43ce-9f93-16eda87ae03b" class="numbered-list" start="1"><li><strong>Центрирование данных</strong>: Вычитание средних значений из данных.</li></ol><ol type="1" id="445aa5c7-9131-44fb-850d-bc2f940ef56e" class="numbered-list" start="2"><li><strong>Вычисление ковариационных матриц</strong>: Определение ковариационных матриц между наборами данных и внутри каждого набора данных.</li></ol><ol type="1" id="a5d956f6-1591-48ed-9134-7e917b1ebd39" class="numbered-list" start="3"><li><strong>Решение обобщенной задачи собственного значения</strong>: Поиск собственных векторов, которые максимизируют корреляцию.</li></ol><p id="3ec49325-3031-410f-95e1-392f8d685f86" class="">Основное различие между PLS и CCA заключается в подходе к максимизации взаимосвязей. PLS фокусируется на максимизации ковариации между проекциями переменных и хорошо работает с многоколлинеарными данными, в то время как CCA максимизирует корреляцию между линейными комбинациями переменных и требует больше наблюдений для стабильной оценки.</p></li></ol></details></li></ul><ul id="13a1633c-357d-4193-abc0-30d44227a66f" class="toggle"><li><details open=""><summary>18. Метод Монте-Карло, Теоретико-вероятностные основы метода.</summary><h3 id="d5a86e01-c4bf-4287-bc8f-4626d88d2924" class="">Метод Монте-Карло: Теоретико-вероятностные основы</h3><p id="d72a37d1-ac4f-401b-bff6-01be91122cb6" class="">Метод Монте-Карло - это численный метод, основанный на генерации случайных чисел и статистических методах. Он используется для приближенного решения различных математических задач, включая вычисление интегралов, решение систем линейных уравнений, симуляцию случайных процессов и т. д. Основными теоретико-вероятностными концепциями, лежащими в основе метода Монте-Карло, являются закон больших чисел и центральная предельная теорема.</p><h3 id="066d667d-aef2-42c1-b028-ba131f97298e" class="">Закон больших чисел</h3><p id="38f8dcf0-f8fe-408a-b45c-25dad340366f" class="">Закон больших чисел гласит, что среднее арифметическое большого числа независимых одинаково распределенных случайных величин приближается к математическому ожиданию этой случайной величины при увеличении числа испытаний. Это позволяет использовать выборочные средние для оценки математического ожидания.</p><h3 id="3e75fdff-fad3-4770-b43a-a5c2bcf911fa" class="">Центральная предельная теорема</h3><p id="008b5eaf-352b-4965-a2d3-603e159ad80f" class="">Центральная предельная теорема утверждает, что сумма большого числа независимых и одинаково распределенных случайных величин имеет распределение, близкое к нормальному, даже если исходные случайные величины не имеют нормального распределения. Это позволяет использовать нормальное распределение для оценки вероятностных характеристик случайных величин.</p><h3 id="c049ddeb-cbda-48e2-adb0-a545bfdb78ff" class="">Принцип работы метода Монте-Карло</h3><ol type="1" id="19aa9e88-9cb8-40b7-9088-3bf5fa42dddc" class="numbered-list" start="1"><li><strong>Генерация случайных чисел</strong>: Случайные числа генерируются с использованием генераторов псевдослучайных чисел или физических процессов.</li></ol><ol type="1" id="e37ea1b7-0e95-4fb1-a29c-a00ea8ce0fb7" class="numbered-list" start="2"><li><strong>Оценка целевой величины</strong>: С использованием сгенерированных случайных чисел оценивается значение целевой величины (например, интеграла или вероятности).</li></ol><ol type="1" id="92c61ad3-2d68-4355-b2a0-9f365ad900d5" class="numbered-list" start="3"><li><strong>Повторение экспериментов</strong>: Процесс повторяется множество раз для уточнения оценки целевой величины.</li></ol><ol type="1" id="8e6722ef-4d17-4ee7-addf-6b9169557e6a" class="numbered-list" start="4"><li><strong>Анализ результатов</strong>: Полученные оценки анализируются с точки зрения точности и сходимости.</li></ol><h3 id="dc8aa306-6d90-4698-a29b-e1dcd7fa1797" class="">Преимущества метода Монте-Карло</h3><ul id="b0cef202-a70d-42cf-a517-a7f5929df3d6" class="bulleted-list"><li style="list-style-type:disc">Простота реализации.</li></ul><ul id="3fe5be62-7d7e-4b9e-8317-d3486f657ca0" class="bulleted-list"><li style="list-style-type:disc">Возможность решения широкого спектра задач.</li></ul><ul id="384b1783-b3d6-4c73-94bd-1ca8536abed8" class="bulleted-list"><li style="list-style-type:disc">Представляет собой универсальный инструмент для приближенного решения сложных математических проблем.</li></ul><h3 id="255ac2e6-defb-4d8e-8d70-edccec0c0f26" class="">Недостатки метода Монте-Карло</h3><ul id="99be3853-f019-4f17-b81c-007b70bf5d8e" class="bulleted-list"><li style="list-style-type:disc">Склонность к медленной сходимости.</li></ul><ul id="04a23295-0ebf-477d-bc19-c122b28a3570" class="bulleted-list"><li style="list-style-type:disc">Требует большого количества случайных испытаний для достижения высокой точности.</li></ul><ul id="f9649bd3-1ba1-4856-adc3-dabb02346f4f" class="bulleted-list"><li style="list-style-type:disc">Не всегда применим для задач с высокой размерностью.</li></ul></details></li></ul><ul id="585aadba-bf3b-4d7c-b0e4-12ebd978ce7d" class="toggle"><li><details open=""><summary>19. Метод Монте-Карло, применение и характеристики</summary><h3 id="992a1eb4-a3d0-41d8-b328-270f79f714af" class="">Метод Монте-Карло: применение и характеристики</h3><p id="db0fcf81-6d94-49e6-ae3e-d1f2ead54b6c" class="">Метод Монте-Карло - это численный метод, основанный на использовании случайных чисел для решения различных математических задач. Он получил свое название в честь казино Монте-Карло в Монако, где случайность игры в азартные игры является ключевым элементом. Этот метод нашел широкое применение в различных областях науки, инженерии, экономике, физике, биологии и финансах благодаря своей гибкости и универсальности.</p><h3 id="95cb974b-37e9-4732-afa4-ec15b0aa9d72" class="">Применение метода Монте-Карло</h3><ol type="1" id="75e972d5-2db3-4fd1-aa30-198a38edd62f" class="numbered-list" start="1"><li><strong>Интегрирование и суммирование</strong>: Метод Монте-Карло может использоваться для численного вычисления интегралов и сумм, особенно в случаях, когда аналитические методы неприменимы из-за сложности функций или размерности пространства.</li></ol><ol type="1" id="2e043686-f437-4327-9f3b-15d9ab96a092" class="numbered-list" start="2"><li><strong>Оценка вероятностей</strong>: Он позволяет оценивать вероятности событий, моделировать случайные процессы и решать задачи, связанные с теорией вероятностей.</li></ol><ol type="1" id="af45c66a-949d-4b68-ad83-6fbfe292fb31" class="numbered-list" start="3"><li><strong>Симуляция и моделирование</strong>: Метод Монте-Карло используется для симуляции различных физических и стохастических процессов, моделирования поведения финансовых рынков, анализа сложных систем и т. д.</li></ol><ol type="1" id="f0c4d8b0-7b3f-4fc8-8e85-18bbfab13076" class="numbered-list" start="4"><li><strong>Оптимизация</strong>: В некоторых случаях метод Монте-Карло может быть применен для решения задач оптимизации путем генерации случайных решений и оценки их качества.</li></ol><h3 id="1dfe8599-921b-4b87-9e26-24f43e3d1f9a" class="">Характеристики метода Монте-Карло</h3><ol type="1" id="2fdd9f5d-222b-46dc-9794-b9a9fab45f0d" class="numbered-list" start="1"><li><strong>Статистический подход</strong>: Он основан на статистических методах и требует генерации большого количества случайных чисел для получения численной оценки.</li></ol><ol type="1" id="a75055a4-3b64-4190-bad7-de12164e4b23" class="numbered-list" start="2"><li><strong>Приближенность</strong>: Результаты метода Монте-Карло обычно являются приближенными, и точность зависит от количества случайных испытаний.</li></ol><ol type="1" id="56b4c660-6547-4c1b-b9a9-adf5e2229f03" class="numbered-list" start="3"><li><strong>Универсальность</strong>: Этот метод подходит для широкого спектра задач и может применяться к различным типам функций и задач, включая многомерные и высокоразмерные пространства.</li></ol><ol type="1" id="5ff5d75b-5029-4d9a-865d-2ccbeb476fa7" class="numbered-list" start="4"><li><strong>Распараллеливание</strong>: Из-за независимости случайных испытаний метод Монте-Карло легко распараллеливается, что позволяет ускорить вычисления с помощью параллельных вычислений.</li></ol></details></li></ul></div></article><span class="sans" style="font-size:14px;padding-top:2em"></span></body></html>